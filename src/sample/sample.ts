export const code_tokens = [
    "<s>",
    "def",
    "\u0120im",
    "sur",
    "fit",
    "\u0120(",
    "\u0120data",
    "\u0120,",
    "\u0120order",
    "\u0120,",
    "\u0120output",
    "_",
    "fit",
    "\u0120=",
    "\u0120False",
    "\u0120)",
    "\u0120:",
    "\u0120c",
    "0",
    "\u0120=",
    "\u0120complex",
    "\u0120(",
    "\u01200",
    "\u0120,",
    "\u0120data",
    "\u0120.",
    "\u0120shape",
    "\u0120[",
    "\u01200",
    "\u0120]",
    "\u0120)",
    "\u0120c",
    "1",
    "\u0120=",
    "\u0120complex",
    "\u0120(",
    "\u01200",
    "\u0120,",
    "\u0120data",
    "\u0120.",
    "\u0120shape",
    "\u0120[",
    "\u01201",
    "\u0120]",
    "\u0120)",
    "\u0120xx",
    "\u0120,",
    "\u0120y",
    "y",
    "\u0120=",
    "\u0120n",
    "umpy",
    "\u0120.",
    "\u0120o",
    "grid",
    "\u0120[",
    "\u0120-",
    "\u01201",
    "\u0120:",
    "\u01201",
    "\u0120:",
    "\u0120c",
    "0",
    "\u0120,",
    "\u0120-",
    "\u01201",
    "\u0120:",
    "\u01201",
    "\u0120:",
    "\u0120c",
    "1",
    "\u0120]",
    "\u0120n",
    "co",
    "eff",
    "\u0120=",
    "\u0120(",
    "\u0120order",
    "\u0120+",
    "\u01201",
    "\u0120)",
    "\u0120*",
    "\u0120(",
    "\u0120order",
    "\u0120+",
    "\u01202",
    "\u0120)",
    "\u0120//",
    "\u01202",
    "\u0120power",
    "list",
    "\u0120=",
    "\u0120list",
    "\u0120(",
    "\u0120_",
    "powers",
    "\u0120(",
    "\u0120order",
    "\u0120)",
    "\u0120)",
    "\u0120b",
    "b",
    "\u0120=",
    "\u0120n",
    "umpy",
    "\u0120.",
    "\u0120z",
    "eros",
    "\u0120(",
    "\u0120n",
    "co",
    "eff",
    "\u0120)",
    "\u0120for",
    "\u0120id",
    "x",
    "\u0120,",
    "\u0120powers",
    "\u0120in",
    "\u0120enumer",
    "ate",
    "\u0120(",
    "\u0120power",
    "list",
    "\u0120)",
    "\u0120:",
    "\u0120p",
    "1",
    "\u0120,",
    "\u0120p",
    "2",
    "\u0120=",
    "\u0120powers",
    "\u0120b",
    "b",
    "\u0120[",
    "\u0120id",
    "x",
    "\u0120]",
    "\u0120=",
    "\u0120(",
    "\u0120data",
    "\u0120*",
    "\u0120xx",
    "\u0120**",
    "\u0120p",
    "1",
    "\u0120*",
    "\u0120y",
    "y",
    "\u0120**",
    "\u0120p",
    "2",
    "\u0120)",
    "\u0120.",
    "\u0120sum",
    "\u0120(",
    "\u0120)",
    "\u0120/",
    "\u0120data",
    "\u0120.",
    "\u0120size",
    "\u0120x",
    "\u0120=",
    "\u0120xx",
    "\u0120[",
    "\u0120:",
    "\u0120,",
    "\u01200",
    "\u0120]",
    "\u0120y",
    "\u0120=",
    "\u0120y",
    "y",
    "\u0120[",
    "\u01200",
    "\u0120]",
    "\u0120w",
    "g",
    "\u0120=",
    "\u0120{",
    "\u0120(",
    "\u01200",
    "\u0120,",
    "\u01200",
    "\u0120)",
    "\u0120:",
    "\u01201",
    "\u0120,",
    "\u0120(",
    "\u0120-",
    "\u01201",
    "\u0120,",
    "\u01200",
    "\u0120)",
    "\u0120:",
    "\u0120x",
    "\u0120**",
    "\u01202",
    "\u0120,",
    "\u0120(",
    "\u01200",
    "\u0120,",
    "\u0120-",
    "\u01201",
    "\u0120)",
    "\u0120:",
    "\u0120y",
    "\u0120**",
    "\u01202",
    "\u0120}",
    "\u0120a",
    "a",
    "\u0120=",
    "\u0120n",
    "umpy",
    "\u0120.",
    "\u0120z",
    "eros",
    "\u0120(",
    "\u0120(",
    "\u0120n",
    "co",
    "eff",
    "\u0120,",
    "\u0120n",
    "co",
    "eff",
    "\u0120)",
    "\u0120)",
    "\u0120for",
    "\u0120j",
    "\u0120,",
    "\u0120c",
    "i",
    "\u0120in",
    "\u0120enumer",
    "ate",
    "\u0120(",
    "\u0120power",
    "list",
    "\u0120)",
    "\u0120:",
    "\u0120for",
    "\u0120i",
    "\u0120,",
    "\u0120r",
    "i",
    "\u0120in",
    "\u0120enumer",
    "ate",
    "\u0120(",
    "\u0120power",
    "list",
    "\u0120[",
    "</s>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>",
    "<unk>"
];
export const comment_tokens = [
    "<s>",
    "Fit",
    "\u0120a",
    "\u0120bid",
    "imensional",
    "\u0120po",
    "lyn",
    "omial",
    "\u0120to",
    "\u0120an",
    "\u0120image",
    "\u0120.",
    "</s>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>",
    "<pad>"
];
export const code_text = "def imsurfit(data, order, output_fit=False):\n    \"\"\"Fit a bidimensional polynomial to an image.\n\n    :param data: a bidimensional array\n    :param integer order: order of the polynomial\n    :param bool output_fit: return the fitted image\n    :returns: a tuple with an array with the coefficients of the polynomial terms\n\n    >>> import numpy\n    >>> xx, yy = numpy.mgrid[-1:1:100j,-1:1:100j]\n    >>> z = 456.0 + 0.3 * xx - 0.9* yy\n    >>> imsurfit(z, order=1) #doctest: +NORMALIZE_WHITESPACE\n    (array([  4.56000000e+02,   3.00000000e-01,  -9.00000000e-01]),)\n\n    \"\"\"\n\n    # we create a grid with the same number of points\n    # between -1 and 1\n    c0 = complex(0, data.shape[0])\n    c1 = complex(0, data.shape[1])\n    xx, yy = numpy.ogrid[-1:1:c0, -1:1:c1]\n\n    ncoeff = (order + 1) * (order + 2) // 2\n\n    powerlist = list(_powers(order))\n\n    # Array with ncoff x,y moments of the data\n    bb = numpy.zeros(ncoeff)\n    # Moments\n    for idx, powers in enumerate(powerlist):\n        p1, p2 = powers\n        bb[idx] = (data * xx ** p1 * yy ** p2).sum() / data.size\n\n    # Now computing aa matrix\n    # it contains \\sum x^a y^b\n    # most of the terms are zero\n    # only those with a and b even remain\n    # aa is symmetric\n\n    x = xx[:, 0]\n    y = yy[0]\n\n    # weights are stored so we compute them only once\n    wg = {(0, 0): 1, (-1, 0): x**2, (0, -1): y**2}\n    # wg[(2,0)] = wg[(-1,0)].sum() / len(x)\n    # wg[(0,2)] = wg[(0,-1)].sum() / len(y)\n\n    aa = numpy.zeros((ncoeff, ncoeff))\n    for j, ci in enumerate(powerlist):\n        for i, ri in enumerate(powerlist[j:]):\n            p1 = ci[0] + ri[0]\n            p2 = ci[1] + ri[1]\n            if p1 % 2 == 0 and p2 % 2 == 0:\n                # val = (x ** p1).sum() / len(x) * (y ** p2).sum() / len(y)\n                val = _compute_weight((p1, p2), wg)\n                aa[j, i+j] = val\n\n    # Making symmetric the array\n    aa += numpy.triu(aa, k=1).T\n\n    polycoeff = numpy.linalg.solve(aa, bb)\n\n    if output_fit:\n        index = 0\n        result = 0\n        for o in range(order + 1):\n            for b in range(o + 1):\n                a = o - b\n                result += polycoeff[index] * (xx ** a) * (yy ** b)\n                index += 1\n\n        return polycoeff, result\n\n    return (polycoeff,)";
export const comment_text = "Fit a bidimensional polynomial to an image.\n\n    :param data: a bidimensional array\n    :param integer order: order of the polynomial\n    :param bool output_fit: return the fitted image\n    :returns: a tuple with an array with the coefficients of the polynomial terms\n\n    >>> import numpy\n    >>> xx, yy = numpy.mgrid[-1:1:100j,-1:1:100j]\n    >>> z = 456.0 + 0.3 * xx - 0.9* yy\n    >>> imsurfit(z, order=1) #doctest: +NORMALIZE_WHITESPACE\n    (array([  4.56000000e+02,   3.00000000e-01,  -9.00000000e-01]),)";
export const code_comment_labels = [[[0, 6], [88, 98, 132, 160, 210, 228]], [[9, 9], [23, 28, 37, 42, 44, 70]]];
