"def imsurfit(data, order, output_fit=False):\n    \"\"\"Fit a bidimensional polynomial to an image.\n\n    :param data: a bidimensional array\n    :param integer order: order of the polynomial\n    :param bool output_fit: return the fitted image\n    :returns: a tuple with an array with the coefficients of the polynomial terms\n\n    >>> import numpy\n    >>> xx, yy = numpy.mgrid[-1:1:100j,-1:1:100j]\n    >>> z = 456.0 + 0.3 * xx - 0.9* yy\n    >>> imsurfit(z, order=1) #doctest: +NORMALIZE_WHITESPACE\n    (array([  4.56000000e+02,   3.00000000e-01,  -9.00000000e-01]),)\n\n    \"\"\"\n\n    # we create a grid with the same number of points\n    # between -1 and 1\n    c0 = complex(0, data.shape[0])\n    c1 = complex(0, data.shape[1])\n    xx, yy = numpy.ogrid[-1:1:c0, -1:1:c1]\n\n    ncoeff = (order + 1) * (order + 2) // 2\n\n    powerlist = list(_powers(order))\n\n    # Array with ncoff x,y moments of the data\n    bb = numpy.zeros(ncoeff)\n    # Moments\n    for idx, powers in enumerate(powerlist):\n        p1, p2 = powers\n        bb[idx] = (data * xx ** p1 * yy ** p2).sum() / data.size\n\n    # Now computing aa matrix\n    # it contains \\sum x^a y^b\n    # most of the terms are zero\n    # only those with a and b even remain\n    # aa is symmetric\n\n    x = xx[:, 0]\n    y = yy[0]\n\n    # weights are stored so we compute them only once\n    wg = {(0, 0): 1, (-1, 0): x**2, (0, -1): y**2}\n    # wg[(2,0)] = wg[(-1,0)].sum() / len(x)\n    # wg[(0,2)] = wg[(0,-1)].sum() / len(y)\n\n    aa = numpy.zeros((ncoeff, ncoeff))\n    for j, ci in enumerate(powerlist):\n        for i, ri in enumerate(powerlist[j:]):\n            p1 = ci[0] + ri[0]\n            p2 = ci[1] + ri[1]\n            if p1 % 2 == 0 and p2 % 2 == 0:\n                # val = (x ** p1).sum() / len(x) * (y ** p2).sum() / len(y)\n                val = _compute_weight((p1, p2), wg)\n                aa[j, i+j] = val\n\n    # Making symmetric the array\n    aa += numpy.triu(aa, k=1).T\n\n    polycoeff = numpy.linalg.solve(aa, bb)\n\n    if output_fit:\n        index = 0\n        result = 0\n        for o in range(order + 1):\n            for b in range(o + 1):\n                a = o - b\n                result += polycoeff[index] * (xx ** a) * (yy ** b)\n                index += 1\n\n        return polycoeff, result\n\n    return (polycoeff,)"